<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lovely</title>
  <style>
    @font-face {
      font-family: 'MyFont';
      src: url('./DF.ttf') format('truetype');
    }

    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(135deg, #1e2a38, #16202b);
      color: #cfd8dc;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // M·∫£ng chu·ªói cho vƒÉn b·∫£n
    const textLines = [
      "Anh y√™u em ‚ù§Ô∏è",
      "Em l√† t·∫•t c·∫£ c·ªßa anh",
      "üåª",
      "üçÄ",
      "M√£i m√£i b√™n nhau",
      "T√¨nh y√™u c·ªßa ch√∫ng ta",
      "H·∫°nh ph√∫c b√™n em",
      "Em l√† √°nh s√°ng c·ªßa anh",
      "C·∫£m ∆°n em ƒë√£ ƒë·∫øn",
      "Anh s·∫Ω y√™u em m√£i m√£i",
      "Em l√† m√≥n qu√† tuy·ªát v·ªùi nh·∫•t",
      "T√¨nh y√™u vƒ©nh c·ª≠u"
    ];

    // M·∫£ng chu·ªói cho link ·∫£nh
    const images = [
      "IMG_0640.JPG",
      "IMG_7453.JPG",
      "IMG_7770.JPG",
      "IMG_8063.JPG",
      "IMG_9605.JPG",
      "IMG_6663.JPG"
    ];

    // ƒê·ªãa ch·ªâ nh·∫°c - t·ª± ƒë·ªông ph√°t khi load trang
    const musicPath = "./music/e.mp3";

    let audio = null;

    // T·ª± ƒë·ªông ph√°t nh·∫°c khi load trang
    function autoPlayMusic() {
      if (musicPath) {
        audio = new Audio(musicPath);
        audio.loop = true;
        audio.volume = 0.5;
        audio.play().catch(error => {
          console.warn('Kh√¥ng th·ªÉ ph√°t nh·∫°c t·ª± ƒë·ªông:', error);
        });
      }
    }

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
    camera.position.z = 400;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // T·∫°o ng√¥i sao
    const starGeo = new THREE.BufferGeometry();
    const starCount = 800; // Gi·∫£m t·ª´ 800 xu·ªëng 400
    const starPos = [];

    for (let i = 0; i < starCount; i++) {
      const r = THREE.MathUtils.randFloat(200, 1000); // Gi·∫£m ph·∫°m vi
      const u = THREE.MathUtils.randFloat(-1, 1);
      const theta = Math.acos(Math.max(-1, Math.min(1, u)));
      const phi = THREE.MathUtils.randFloat(0, 2 * Math.PI);

      const x = r * Math.sin(theta) * Math.cos(phi);
      const y = r * Math.sin(theta) * Math.sin(phi);
      const z = r * Math.cos(theta);

      if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
        starPos.push(x, y, z);
      }
    }

    starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));

    // T·∫°o texture h√¨nh tr√≤n cho ng√¥i sao
    const starCanvas = document.createElement('canvas');
    starCanvas.width = 32;
    starCanvas.height = 32;
    const starCtx = starCanvas.getContext('2d');

    // V·∫Ω h√¨nh tr√≤n
    starCtx.fillStyle = '#FFCE45';
    starCtx.beginPath();
    starCtx.arc(16, 16, 12, 0, 2 * Math.PI);
    starCtx.fill();

    const starTexture = new THREE.CanvasTexture(starCanvas);
    const starsMat = new THREE.PointsMaterial({
      color: 0xFFCE45,
      size: 5,
      transparent: true,
      opacity: 0.7,
      sizeAttenuation: true,
      map: starTexture
    });
    scene.add(new THREE.Points(starGeo, starsMat));

    // Th√™m ng√¥i sao g·∫ßn h∆°n ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng ƒë·∫πp
    const nearStarGeo = new THREE.BufferGeometry();
    const nearStarCount = 200;
    const nearStarPos = [];
    for (let i = 0; i < nearStarCount; i++) {
      const r = THREE.MathUtils.randFloat(200, 600);
      const theta = Math.acos(THREE.MathUtils.randFloatSpread(2));
      const phi = THREE.MathUtils.randFloat(2 * Math.PI);
      nearStarPos.push(
        r * Math.sin(theta) * Math.cos(phi),
        r * Math.sin(theta) * Math.sin(phi),
        r * Math.cos(theta)
      );
    }
    nearStarGeo.setAttribute('position', new THREE.Float32BufferAttribute(nearStarPos, 3));

    // T·∫°o texture h√¨nh tr√≤n cho ng√¥i sao g·∫ßn
    const nearStarCanvas = document.createElement('canvas');
    nearStarCanvas.width = 32;
    nearStarCanvas.height = 32;
    const nearStarCtx = nearStarCanvas.getContext('2d');

    // V·∫Ω h√¨nh tr√≤n
    nearStarCtx.fillStyle = '#ffffff';
    nearStarCtx.beginPath();
    nearStarCtx.arc(16, 16, 12, 0, 2 * Math.PI);
    nearStarCtx.fill();

    const nearStarTexture = new THREE.CanvasTexture(nearStarCanvas);
    const nearStarsMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 12,
      transparent: true,
      opacity: 0.2,
      sizeAttenuation: true,
      map: nearStarTexture
    });
    scene.add(new THREE.Points(nearStarGeo, nearStarsMat));

    // Images and text
    const textureLoader = new THREE.TextureLoader();
    const group = new THREE.Group();
    scene.add(group);

    function randomPosOnSphere(radius) {
      const theta = Math.acos(THREE.MathUtils.randFloatSpread(2));
      const phi = THREE.MathUtils.randFloatSpread(2 * Math.PI);
      return new THREE.Vector3(
        radius * Math.sin(theta) * Math.cos(phi),
        radius * Math.sin(theta) * Math.sin(phi),
        radius * Math.cos(theta)
      );
    }

    function createTextSprite(text) {
      const canvas = document.createElement('canvas');
      const size = 512;
      canvas.width = size;
      canvas.height = 128;
      const context = canvas.getContext('2d');
      const colors = ['#ff679a', '#63c7c7', '#76b776'];
      let colorIndex = 0;
      const texture = new THREE.CanvasTexture(canvas);
      texture.minFilter = THREE.LinearFilter;
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 1.0 });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(150, 40, 1);

      function updateText() {
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = '#ffffff00';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillStyle = colors[colorIndex];
        context.lineWidth = 1;
        context.strokeStyle = '#ff8690';
        context.font = '48px MyFont';
        context.fillText(text, size / 2, 64);
        context.strokeText(text, size / 2, 64);
        texture.needsUpdate = true;
      }

      updateText();
      setInterval(() => {
        colorIndex = (colorIndex + 1) % colors.length;
        updateText();
      }, 10000);

      return sprite;
    }

    const planes = [];
    const labels = [];
    const imagePositions = [];
    const textPositions = [];
    const boxCount = 30;
    const radiusImage = 300;
    const radiusText = 350;

    function initScene() {
      group.clear();
      planes.length = 0;
      labels.length = 0;
      imagePositions.length = 0;
      textPositions.length = 0;

      if (images.length === 0 || textLines.length === 0) return;

      for (let i = 0; i < boxCount; i++) {
        const size = 20 + Math.random() * 10;
        const texture = textureLoader.load(images[i % images.length]);

        // T·∫°o geometry v·ªõi t·ªâ l·ªá 1:1 (vu√¥ng)
        const geometry = new THREE.PlaneGeometry(size, size);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: false });
        const mesh = new THREE.Mesh(geometry, material);

        // ƒêi·ªÅu ch·ªânh scale ƒë·ªÉ gi·ªØ t·ªâ l·ªá ·∫£nh v√† l√†m ·∫£nh r√µ n√©t h∆°n
        texture.addEventListener('load', function () {
          const aspectRatio = texture.image.width / texture.image.height;
          if (aspectRatio > 1) {
            // ·∫¢nh ngang
            mesh.scale.set(0.1 * aspectRatio, 0.1, 0.1);
          } else {
            // ·∫¢nh d·ªçc
            mesh.scale.set(0.1, 0.1 / aspectRatio, 0.1);
          }
        });

        const pos = randomPosOnSphere(radiusImage);
        imagePositions.push(pos);
        mesh.position.set(0, 0, 0);
        mesh.scale.set(0.1, 0.1, 0.1); // Scale m·∫∑c ƒë·ªãnh l·ªõn h∆°n
        mesh.userData = { progress: 0, speed: 0.0005 + Math.random() * 0.0005, delayOffset: i * 0.02 };
        group.add(mesh);
        planes.push(mesh);
      }

      for (let i = 0; i < boxCount * 2; i++) {
        const text = textLines[i % textLines.length];
        const sprite = createTextSprite(text);
        const pos = randomPosOnSphere(radiusText);
        textPositions.push(pos);
        sprite.position.set(0, 0, 0);
        sprite.scale.set(1.5, 0.4, 1);
        sprite.userData = { progress: 0, speed: 0.0005 + Math.random() * 0.0005, delayOffset: i * 0.02 };
        scene.add(sprite);
        labels.push(sprite);
      }
    }

    function updateLabelText(index, text) {
      if (index < 0 || index >= labels.length) return;
      const label = labels[index];
      if (label) {
        scene.remove(label);
        label.material.map.dispose();
        label.material.dispose();
      }
      if (text.trim() === '') {
        labels[index] = null;
        return;
      }
      const newSprite = createTextSprite(text);
      newSprite.position.copy(textPositions[index]);
      scene.add(newSprite);
      labels[index] = newSprite;
    }

    let targetRotX = 0;
    let targetRotY = 0;
    let currentRotX = 0;
    let currentRotY = 0;
    const maxRotX = Math.PI / 6;
    const maxRotY = Math.PI / 4;

    function updateTargetRotation(x, y) {
      const normalizedX = x / window.innerWidth * 2 - 1;
      const normalizedY = y / window.innerHeight * 2 - 1;
      targetRotY = normalizedX * maxRotY;
      targetRotX = normalizedY * maxRotX;
    }

    window.addEventListener('mousemove', event => {
      updateTargetRotation(event.clientX, event.clientY);
    });

    window.addEventListener('touchmove', event => {
      if (event.touches.length > 0) {
        const touch = event.touches[0];
        updateTargetRotation(touch.clientX, touch.clientY);
      }
    }, { passive: true });

    // T·∫°o link chia s·∫ª
    const shareLinkEl = document.getElementById('shareLink');
    const copyMsg = document.getElementById('copyMsg');

    // function createShareLink() {
    //   const data = {
    //     textLines: textLines,
    //     imageLinks: images,
    //     music: musicPath
    //   };
    //   const jsonData = JSON.stringify(data);
    //   const encoded = btoa(encodeURIComponent(jsonData).replace(/%(\w{2})/g, (_, hex) => String.fromCharCode('0x' + hex))).replace(/[+/=]/g, char => ({ '+': '-', '/': '_', '=': '' }[char] || ''));
    //   const url = new URL(location.origin + location.pathname);
    //   url.hash = 'data=' + encoded;
    //   shareLinkEl.href = url.toString();
    //   shareLinkEl.textContent = url.toString();
    //   shareLinkEl.style.display = 'inline-block';
    // }

    // shareLinkEl.addEventListener('click', () => {
    //   navigator.clipboard.writeText(shareLinkEl.href).then(() => {
    //     copyMsg.style.display = 'inline';
    //     setTimeout(() => {
    //       copyMsg.style.display = 'none';
    //     }, 2000);
    //   }).catch(error => console.error('Kh√¥ng th·ªÉ sao ch√©p:', error));
    // });

    function animate() {
      requestAnimationFrame(animate);

      currentRotX += (targetRotX - currentRotX) * 0.05;
      currentRotY += (targetRotY - currentRotY) * 0.05;

      const distance = 400;
      camera.position.x = distance * Math.sin(currentRotY) * Math.cos(currentRotX);
      camera.position.y = distance * Math.sin(currentRotX);
      camera.position.z = distance * Math.cos(currentRotY) * Math.cos(currentRotX);
      camera.lookAt(0, 0, 0);

      const lerpToTarget = (target, start) => new THREE.Vector3(target.x, target.y + 1000, target.z);

      planes.forEach((plane, index) => {
        let progress = plane.userData.progress - plane.userData.delayOffset;
        if (progress < 0) progress = 0;
        else if (progress > 1) progress = 1;

        const target = lerpToTarget(imagePositions[index]);
        plane.position.lerpVectors(target, imagePositions[index], progress);

        let scale = 0.1 + progress * (3 - 0.1);
        plane.scale.set(scale, scale, scale);

        plane.userData.progress += plane.userData.speed;
        if (plane.userData.progress > 1 + plane.userData.delayOffset) {
          plane.userData.progress = 0;
        }

        const label1 = labels[2 * index];
        if (label1) {
          label1.visible = progress > 0;
          const target1 = lerpToTarget(textPositions[2 * index]);
          label1.position.lerpVectors(target1, textPositions[2 * index], progress);
        }

        const label2 = labels[2 * index + 1];
        if (label2) {
          label2.visible = progress > 0;
          const target2 = lerpToTarget(textPositions[2 * index + 1]);
          label2.position.lerpVectors(target2, textPositions[2 * index + 1], progress);
        }
      });

      renderer.render(scene, camera);
    }

    // Kh·ªüi t·∫°o scene v√† b·∫Øt ƒë·∫ßu animation ngay khi load trang
    window.addEventListener('load', () => {
      autoPlayMusic();
      initScene();
      for (let i = 0; i < planes.length; i++) {
        let text = '';
        if (textLines.length > 0) {
          text = textLines[i % textLines.length];
        }
        updateLabelText(i, text);
      }
      createShareLink();
    });

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
